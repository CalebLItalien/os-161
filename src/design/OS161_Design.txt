I. OS/161 Extension
In this project, we will be modifying and extending OS/161 so that it will allow multiple concurrent user processes to be scheduled, as well as to interact with the file system. In order to implement this, we will make the kernel have multiple threads that can be run, so that we can use a one-to-one design of user to kernel threads in which each user thread corresponds to one kernel thread. Since we do not expect any processes to be of very high priority on this operating system, we will not make the kernel threads preemptive, as all threads will be considered to have an equal priority. The structures that will need to be added to the operating system are a process table to keep track of the processes that are running. Also, we will need to create a data structure for the scheduling queue that we will be implementing into the system. Lastly, we will need to create a file table for keeping track of the files that are open. When we are handling process termination, we will allow parent processes to terminate the execution of its children. This is because when a parent process is terminated, we will want all of its children to be terminated as well, using the cascading termination method. Moreover, when the process is terminated, all of its resources will be deallocated to allow for more processes to be run. 
        The protection in our data structures will be important for ensuring the operating system can run smoothly. In order to protect the data structures, syscalls that are interacting with the data structures will use locks so that interleaving will not occur and make the data inside the data structures protected. Furthermore, in order to protect the kernel and user processes from other processes, the threads will be one-to-one, which will keep the processes from interfering with one another. 
        The scheduling policy that we will implement for this extension will be the first come first serve scheduling policy. We are doing this as the policy prevents starvation from occurring. Also, since we will be treating all processes as having the same priority in this operating system, the scheduling policy will not need to be preemptive and therefore first come first serve works well in this design. 
        Concurrent file accesses will occur in some of the file syscalls. Therefore, in order to manage this, we will have locks on all file accesses to prevent issues from occurring.
When we are transferring data to and from the user data and kernel data, we will use the OS/161 built-in features copyin and copyout, as well as uimove in order to move the data. 
So that our project repository is well managed for this assignment, we will be using feature branches for each feature that we are adding. This will help to prevent merge conflicts when we are attempting to push to the repository. Also, we will not push our changes until a feature is implemented in a way that is not detrimental to the operating system.


II. Syscalls
The getPid() syscall returns the process id of the current process. This syscall will need access to the process control block of the current process. The function fails when it cannot access the process control block or returns an incorrect process id. Process ids will be counted starting from 1.
The fork() syscall duplicates a given process, and the new process (a duplication of the original process, with a different address space) is given a unique process id. The parent (original) process maintains its original process id. The child process returns 0, and the parent process returns the unique process id of the child process. The syscall will need to make a copy of the parent’s trapframe data structure (values of CPU registers, address space, stack state, etc) and pass a pointer to it to the child process. A copy must be made to ensure that parent and child processes cannot cause data corruption. However, parent and child processes will have the same file handlers, so edits to a file in one process can affect the other process. Information regarding the state of the CPU, parent process’ address space, and accesses to the file system will need to be moved between user space and kernel space, so locks on accesses to the state of the CPU and address space will be necessary. Upon error, the syscall returns -1 and does not create a child process and errno is set with the given error accordingly. 
1. Pseudocode draft:
   1. Create a copy of the parent’s trapframe
   2. Create entry point to child process
      1. return -1 if error, set errno
   3. Pass pointer to copy of parent’s trapframe to child process
   4. Create thread for child process
   5. Keep child process from running until file table can be passed to it
      1. will need to use synchronization primitives
   6. Parent process returns pid of child process, child process returns 0


The read() syscall reads a number of bytes of a file from a given location in that file, that location determined by the current seek position. This call will need access to the file system and will need to pass the bytes read to userland from the kernel. The syscall will need to be synchronized, to ensure reads to the file are atomic with respect to other processes. Multiple threads within a given process can read the same file at the same time. An error would have the syscall return -1 and set errno to the proper error.
The dup2() syscall clones the file handle that is passed through the parameter oldfd, onto a new file handle parameter newfd. If the newfd is an already open file, then that file is then closed. This system call will need to use the file component of OS/161 in order to implement. It will also need to use the file table to check if it is full or not. This will need to use synchronization, as there could be interleaving if multiple threads try to call this syscall, for then an old file could be closed while a new file is open, leading to issues. The error states that can occur are that the oldfd parameter is not a valid file handle or newfd is not a valid file handle, the file table for the process is full or there were too many files open, or the system’s file table is full. This will return the value -1 and change errno value. Data will not need to be moved from user data into kernel data for this system call.
The waitpid() syscall returns the process id whose exit status is reported in pid. It takes in a current process id,  status of the process and exit options. It fails when a process does not exist. Only a parent process can collect its childs exit status. Since we terminate the child as soon as the parent terminates, we do not need to worry about the parent not getting the child's exit status to a parent that has already exited. This syscall will not need another struct but will be getting data from the PCB struct. This would contain data for each process. We do not have to implement any options. Hence that argument is always 0. This will require a locking mechanism. If there is an error, -1 is returned and errno is set to the correct error code.
        The exit() syscall terminates a currently running process. I will have dependence on the proc struct. This function does not return anything. Due to our exit policy, we must end all child processes when the parent process ends. This will involve using locks. For full implementation, fork and exec should be implemented before. 
The open() syscall opens the file, device, or other kernel object named by the pathname filename. The flags argument specifies how to open the file. It returns a nonnegative file handle. If there is an error, -1 is returned and set errorno depending on the error. This needs locks so that no other processes do not access the same file thereby corrupting it. This will access the vnode struct, vfs.h and fs.h. 
The close() syscall closes an already open file. It recognises the file to close using a file handle. One thing to note here is that while implementing this, we must make sure that the file we are trying to close is currently open. This returns 0 when successful and -1 when it is unsuccessful. This does not need any synchronization mechanisms. This will access the vnode struct, vfs.h and fs.h. Open and dup2 must be implemented before 
The execv() syscall is supposed to change from the current executing process to a new executable process based on the pathname of the program to run, which is passed in as the parameter program. This process will interface with the lock component of OS/161 so that interleavings will not occur. Furthermore, it will interact with the error codes in OS/161 in case an error occurs and the system will return one of these, using errno. It will also interact with the virtual memory, as it will need to have an address space made based on the size of the argv. This syscall will need to use synchronization, because if too many processes are trying to call execv, it could cause the system to choke. Therefore, the locks will be used to prevent too many processes to call execv. The errors that can occur are that the device prefix for the program parameter does not exist, a part of the program is not a directory, program does not exist, the format of program is wrong, there was insufficient virtual memory for the program to run, the argument strings size was greater than the system constant for maximum argument size, an I/O error occurs, or one of the arguments is an invalid pointer. Data will need to be moved from user data to the kernel data, as the function gets past parameters that are pointers. Therefore, this data will need to be moved into the kernel in order to run the new program.
The lseek() syscall is supposed to change the current seek position of the file passed as a parameter with its filepath. This will allow read/writes to be done in different positions in the file. The syscall will need to be atomic, meaning that it will interact with locks in order to prevent others from accessing the syscall while another process is trying to use it. The error states that can occur during this are that the file handle is invalid, the file handle is not supported by seeking, the whence parameter is invalid, or the seek position would turn out to be negative. Data will not need to be moved from user space to kernel space for this syscall.
The chdir() syscall is supposed to change the current directory that is being used. This will work with locks in order to keep the syscall atomic. The error states that can occur for this syscall are that the pathname for the desired directory does not exist, a non-final part of the pathname is not a directory, the pathname is not a directory or does not exist, an I/O error occurs, or the pathname is not a valid pointer. Data will need to move from the user data to the kernel data, since the path of the directory is being passed as a pointer.
The __getcwd() syscall is supposed to get the name of the current working directory. The syscall will use locks to be atomic and will also use memory to store the name of the directory. The errors that can occur for this are that a part of the pathname for the directory no longer exists, an I/O error occurs, or the parameter for storing the directory name is invalid. This will have to move data between user mode and kernel mode, as we need to get the current working directory that is being passed in as a pointer.
The write() syscall is supposed to write up to a certain amount of bytes to a file that is given through the parameter fd. Furthermore, the seek position of the file is moved forward the amount of bytes that are being written to the file. The system will need to be atomic to other I/O for the same file to prevent interleavings from occurring.This syscall will use the file table to find the file and will also use the built in structs for files in OS/161. Data will need to be moved between user and kernel, as the syscall is writing to a file given a user input.


III. Assignments
        The following assignments are being made to complete this project based on the above 
design for the extension of the OS/161 operating system:
        Caleb: getpid(), fork(), waitpid(), _exit(), Process Table
Jack: execv(), close(), __getcwd(), lseek(), Scheduling Queue, ⅔ File Table
Manav: open(), read(), write(), chdir(), dup2(), ⅓ File Table


________________


Matt notes:
* we have to implement the syscalls, not much to work with, have to write on signatures
* systime shows how to work with user pointers
* user-level threads need to be user-level atomic, not os atomic
* file operations need to be atomic on the file
* each process has one kernel thread
   * experiment with different upper limits
* if given pointer by user, like a char * which is in user space, need to copy to os
* execv has nested pointers
* locks inside the file table
* need to keep track of which files are open at any given time
* set errno variable in syscall.c to specified error to return it to the user