We put an yield statement in linkedlist_prepend() right after we determine that list -> first != NULL and create a new node.
This causes adder 1 and adder 2 to be intreleaving such the result from adder 1 and 2 to have certain elements duplicated.

This mainly results adder 3 to give up the thread to insert 3 until the thread is available again.

We were expecting this to happen. 

original output:

testnum: 0
final list from adder1: -9[J] -8[I] -7[H] -6[G] -5[F] -4[E] -3[D] -2[C] -1[B] 0[A] 
final list from insert3: 0[B] 1[E] 2[A] 3[D] 4[G] 5[F] 6[C] 
final list from remove head5: 
final list from adder2: -19[J] -18[I] -17[H] -16[G] -15[F] -14[E] -13[D] -12[C] -11[B] -10[A] -9[J] -8[I] -7[H] -6[G] -5[F] -4[E] -3[D] -2[C] -1[B] 0[A] 
final list from remove head4: 1[E] 2[A] 3[D] 4[G] 5[F] 6[C] 
peration took 0.022247920 seconds

actual output:
OS/161 kernel [? for menu]: llt 1
testnum: 1
final list from insert3: 0[B] 1[E] 2[A] 3[D] 4[G] 5[F] 6[C] 
final list from remove head5: 
final list from remove head4: 1[E] 2[A] 3[D] 4[G] 5[F] 6[C] 
final list from adder1: -9[J] -8[H] -8[I] -7[G] -7[H] -6[F] -6[G] -5[E] -5[F] -4[D] -4[E] -3[C] -3[D] -2[B] -2[C] -1[A] -1[B] 0[A] 
final list from adder2: -10[J] -9[I] -9[J] -8[H] -8[I] -7[G] -7[H] -6[F] -6[G] -5[E] -5[F] -4[D] -4[E] -3[C] -3[D] -2[B] -2[C] -1[A] -1[B] 0[A] 
eration took 0.022242680 seconds
